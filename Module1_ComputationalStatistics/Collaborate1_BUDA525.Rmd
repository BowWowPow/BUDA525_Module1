---
title: "Collaborate Session 1"
author: "BUDA 525"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```
## Why Bootstrap

Up to this point I've discussed bootstrap in the context of means, we can use it
for almost anything.  One of the more important things it can do is give us insight
when the CLT or sampling distribution is intractable. 

Assume we have the $p$th quantile $\theta$ of a random variable that comes from Distribution $F$, with probability mass/density function $f$. The sample $p$th quantile for out data is $\hat{\theta}$.  Basically what we are saying is that we know the distribution of $f$, but is that reality?  No in reality we don't really know the distribution of any of our data. But let's see how this all plays in anyways. The sampling distribution for $\hat\theta$ is 

$$
\hat\theta\sim N(\theta, \frac{p(1-p)}{nf^2(\theta)}).
$$

So really to apply our CLT we have to assume what the distribution of the data is, which is a fairly big assumption.  Instead we can bootstrap this distribution.  

```{r}
install.packages("ISLR")
library(ISLR)
dim(College)
head(College)
# storeIntVar <- table$GetDataInTable


apps<-College$Apps
# we run sampling distros based on loads of different seeds. 
# Each time we random this, we will get different sampling data. 
# working hard to then run the code multiple times to see the difference in
# variation 
# -- This is the old way -- 
set.seed(1337)

# setting up an empty var for use later. Delegates 

bootsApp<-NULL
# First thing that looks like code. thank you. 
# "most efficient way" 
for(j in 1:10000){
  bootsApp<-c(bootsApp,median(sample(apps,length(apps),replace = TRUE)))
}
bootsApp<-NULL
# writing as dplyr
library(dplyr)
for(j in 1:1000){
  # samples apps as size apps - with replacement. Then take that and calc the
  # medium of that example
  # said about changing medium to the other one and it "would work" 
  # also we need to change the seed 
  my_samp=apps%>%sample(.,length(.),replace=TRUE)%>%mean()
  bootsApp<-c(bootsApp,my_samp)
}

hist(bootsApp)

quantile(bootsApp,c(.1,.9))
```



## Matrix Example

Looking at wages of 3000 workers in the Mid-Atlantic, doing 10000 bootstrap samples
```{r}
## install.packages("ISLR")
library(ISLR)
head(Wage)
help(Wage)
summary(Wage)
hist(Wage$wage)
set.seed(1040)
store<-matrix(0,3000,10000)
for(i in 1:10000){
  store[,i]=sample(Wage$wage,3000,replace=TRUE)
}
boots<-apply(store,2,mean)
length(apply(store,2,mean))
hist(boots)
dim(boots)
length(boots)
dim(store)
quantile(boots,c(.1,.9))
quantile(boots,c(.05,.95))
quantile(boots,c(.25,.75))

set.seed(2626)
# he's deciding to do 10,000 reps and store those in 3000 rows
# storing it in store
store<-matrix(0,3000,10000) # default value, cols, rows 

for(i in 1:10000){
  # create the 
   store[,i]=sample(Wage$wage,3000,replace=TRUE)
}

# take this func and apply it to the cols and rows (1,2)
boots<-apply(store,2,mean)
quantile(boots,c(.1,.9))
```

## List Example
```{r}
bstore<-NULL
bstore
set.seed(1234)
for(k in 1:1000){
bstore[[k]]=sample(Wage$age,3000,replace=TRUE)
}
dim(bstore)
length(bstore)
bootsl<-sapply(bstore,mean)
hist(bootsl)
quantile(bootsl,c(.1,.9))


bstore<-NULL
set.seed(154)
# Time between frames
# Set curTime pre 4lp
Mine<-Sys.time()
for(k in 1:1000){
bstore[[k]]=sample(Wage$age,3000,replace=TRUE)
}

bootsl<-sapply(bstore,mean)
# Time between frames
# time after 4lp
Mine2<-Sys.time()
# Time between frames
Mine2-Mine
hist(bootsl)
# subset with the last 10% and 90%
quantile(bootsl,c(.1,.9))
```

## No Storage Example

Now we want to compare salaries between jobclass

Is the mean salary for information workers higher than industrial workers? 


```{r}
# this is importat - tapply - find out that thing
mclass<-tapply(Wage$wage,Wage$jobclass,mean)
my_stat<-mclass[2]-mclass[1]
my_stat
##Info-Industrial>0 (Alt Hyp)
## Info-Industiral=0 (Null Hyp)
## We want to generate the null hypothesis that the two means are equal
## We want to know do info make more than industrial (avg higher)
set.seed(1900)
samp_d<-NULL
for(j in 1:10000){
  # Create a new data frame and mix up the job class over and over. 
  NewDat<-data.frame(w=Wage$wage,jc=sample(Wage$jobclass,3000))
  my_stat_boot<-tapply(NewDat$w,NewDat$jc,mean)
  samp_d<-c(samp_d,my_stat_boot[2]-my_stat_boot[1])
}
hist(samp_d,xlim=c(-20,20))
# WE CANNOT CALL THIS BY ITSELF 
abline(v=my_stat)
# This generates a black line that is off the screen. 
# the line is meant to represent something like - the data doesn't represent
# the null. -- ??? 
sum(samp_d>=my_stat)/10000
# there are 0 times our last sets didn't show up in the distro
```